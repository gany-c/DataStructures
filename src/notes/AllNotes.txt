ALL NOTES:-


BLOOM FILTER:

 * BloomFilter is a data structure for quick boolean lookups with a small chance of false positives
 * e.g. is a username lookup at the time of registration. Some false positives are allowed.
 * 
 * in the example below an integer is stored as 3 bits in a bit array. 
 * The position of the bits is determined by the hash function
 * 
 * HASH FUNCTION: takes 3 numbers as input
 * 1. the number to be stored
 * 2. a constant term
 * 3. array size 
 *  and returns a bit index.
 *  
 *  This function is called with 3 different constant terms for each number that is to be stored.
 *  While checking, the same 3 numbers are used.
 *
 * 
 * the percentage of false postives can be tweaked by
 * 
 * 1. size of the bit array - just has to be large, needn't be prime
 * 2. the coefficients used in calculation of the hashes - have to be relatively large and prime
 * 2.a. 2 digit primes work better than 4 digit non primes.
 
GEOMETRY - FIND THE MAXIMUM NUMBER OF COLLINEAR POINTS

	 * 1. Find the maximum number of collinear points for each point in the list
	 * 2. return the maximum
	 * 
	 * 1.findMaxNumForPoint: Given one target point and the rest, 
	 * 1.1 --- Calculate the slope of the target with every other point
	 * 1.2. --- store the result in a slope to count map
	 * 2. Return the max count slope plus 1; (first slope, encompasses 2 points)
	 * 
	 * 1. getSlope
	 * 1.1. Check for division by 0
	 * 1.2. In Java, there is something called negative 0.0
	 http://stackoverflow.com/questions/6724031/how-can-a-primitive-float-value-be-0-0-what-does-that-mean
	 * 1.3. In general geometry, slope can be negative; 
	 * but the slope between 2 points will remain the same regardless of which point is used first

MATRIX, NUMBER OF DISTINCT PATHS TO ORIGIN:

RECURSION: - Sum of left cell + sum of right cell

 MATRIX MULTIPICATION
	 * 
	 * 1. INVOLVES 3 NESTED LOOPS.
	 * 2. THE FIRST 2 LOOPS ARE FOR visiting each cell of the output matrix. Build the output first
	 * 3. THE THRID LOOP IS TO do the sum or products of input 1's row and input's column

MATRIX, ISLAND EXPLORATION:-

 * A matrix is split into islands, by a sea of zeroes :)
 * Find the island with the largest sum
 * 
 * 1. Create a boolean matrix of same dimensions - to say which pixel is visited.
 * -- alternative could be set it to 2.
 * 2. Traverse the original matrix, row by row, 
 * 2.1. if the pixel is not zero and it is not marked visited in the other matrix,
 * 2.2. Start a recursive function, for exploring
 * 2.2.1 it should add it's own value to the sum and recursively call all its neighboring pixels
 * 2.2. Once the sum is returned, compare it with the maximum sum recorded.
 * 
 * Note:- Even though the traversal goes from top to bottom, an upwards neighbor recursion is also 
 * necessary. Otherwise, will fail if the island is U shaped with right bar of the U shorter 
 *  than the left bar
 
 MATRIX, N QUEENS PROBLEM, BACKTRACKING:-
 
  * The N Queen is the problem of placing N chess queens on an N×N chessboard so that no two queens attack each other.
 * 
 * 1. Traverse the board, starting from the first row, and move to the other rows recursively
 * 2. In each row - check if a cell is a valid cell for placing the queen
 * 2.1. if not check the next cell
 * 2.2. if yes, mark it as a queen position
 * 2.2.1 Do a recursive check for the next rows from there
 * 2.2.2 if that succeeds, return true
 * 2.2.3 Else reset the position to 0
 * 
 * MISTAKES made - 
 * 1. Wrongly assumed both diagonals will be of same size and hence can be checked in one loop
 * 2. Counter  > and < typo
 * 3. Counter array.length and array.length -1 confusion.
 
 MATRIX, BACKTRACKING, SUDOKU
 
  * Problem class - Backtracking 
 * http://www.geeksforgeeks.org/backtracking-set-7-suduku/
 * 
 * High level algorithm is like this:-
 * 
 * 1. If the cell is prefilled skip
 * 2. start at the left corner
 * 2.1. Build a candidate set of numbers which don't violate the row, column or cell constraints
 * 2.2.1 for each candidate number, fill it at the current cell and check if you can solve the entire downstream - recursively
 * ----------If yes, you have a solution, return true;
 * ----------If no, you can reset the cell and fill it with the next candidate number.
 * 2.3. if you are out of candidate numbers, there is no solution; return false
 *
 * MISTAKES MADE:-
 * 1. In the cell boundry calculation, took the quotient itself as the lower bound,
 * --- should have taken quotient * cell size
 * 
 * 2. Forgot to skip over non-zero i.e. prefilled values.
 
 SEARCH, FAULTY CHECKIN FINDER:-
 
 Given a boolean list of flags, representing a history of checkins, find the first faulty check in.
 
 * do the  null and size check. 
 * If the last element is true, then all is well, return -1
 * if the first element is false then return the first index, i.e. 0
 * Otherwise, kick in the search process.
 
 * Do a binary search to find the transition
 * 1. if you hit a false, then check if the previous element was true
 * 2. if you hit a true, check if the succeeding element is false
 * 3. Move the search index by treating "true" as a smaller value than "false" 
 
 SEARCH - BINARY SEARCH IN GENERAL :)
 
 These are the following factors:-
 
 1. Do you need to return a boolean found vs not-found or you have to return the index and possible insertion index?
 2. Are you going set the next end and start as mid or mid+-1
 3. Is it a single comparison for the value at mid or does it also involve the values +-1 at mid? 
 This is done for transition check e.g. first strictly greater value
 4. Termination: start == mid can happen in two cases, start = end and start +1 =end. 
 This can become an infinite loop if the recursive limits are set to previous mids
 
 General pattern:- Wrapper and recursive function
 
In the wrapper:- 
	 * 1. check for null conditions
	 * 2. check for the extremities
	 * 3. Start the recursive function
	 * 
	 * BINARY SEARCH has TWO VARIATIONS - 
	 * -- Search for a transition between 2 states - first faulty checkin or first strictly greater value
	 * -- Find index -- Return the index of a value or any valid place where it can be inserted
	  Can't 2 be written as 1? i.e. with check at mid and at adjacent values
	 * 
	 * In the second case, Making the recursive with a mid +1 or mid -1 can take the target value outside the range
	 * e.g. { 1,5,9,13,17},8
	 * e.g. { 1,5,9,13,17},12
	 * 
	 * In the first case, we are comparing mid with its adjacent elements so it is OK 
	 * - here you can use mid +1 and mid -1 and break out, without making recursion ending code.
	 * 
	 * 3.1. If the element at mid is the same as what you were looking for, return mid
	 * 3.2. Check if start == mid. This can happen in 2 cases 
	 *  1. start and end are adjacent
	 *   - here the value is strictly greater than start, but less than or equal to end, 
	 *   - so return start +1 or mid +1 or end.
	 *  2. start and end overlap - 
	 *  depending on how the value at mid compares with the input value, return an index 1 greater or mid itself 
	 *  (will get pushed if a new value is inserted)
	 
BINARY SEARCH - Return the smallest character that is strictly larger than the search character,

	 * Return the smallest character that is strictly larger than the search character,
	 * otherwise return the first character in the string.
	 * @param sortedStr : sorted list of letters, sorted in ascending order.
	 * @param c : character for which we are searching.
	 * Given the following inputs we expect the corresponding output:
	 * ['c', 'f', 'j', 'p', 'v'], 'a' => 'c'
	 * ['c', 'f', 'j', 'p', 'v'], 'c' => 'f'
	 * ['c', 'f', 'j', 'p', 'v'], 'k' => 'p'
	 * ['c', 'f', 'j', 'p', 'v'], 'z' => 'c' // The wrap around case
	 * ['c', 'f', 'k'], 'f' => 'k'
	 * ['c', 'f', 'k'], 'c' => 'f'
	 * ['c', 'f', 'k'], 'd' => 'f'
	 * @throws Exception 
	 * 
	 * SOLUTION:-
	 * 1. Have a non recursive wrapper method which checks for 
	 * 1.a. input being null or empty
	 * 1.b. and falling out of the range i.e. lesser than minimum and larger than maximum
	 * 2. Then initiate the recursive method.
	 * 2.a. mid equals end, only if start and end are the same number.
	 * 2.b. mid can equal start both if start and end have merged and start is one lesser than end.	 
	 
BINARY SEARCH -	 Search in a sorted but, rotated array.	 - TO BE DONE
	 
LIST - Shortest distance in a dictionary 

 * PROBLEM: Given a list of words whre each word could appear multiple times; 
 * and a pair of words, find the shortest distance between them.
 * 
 * SOLUTION:
 * 1. Build a map with words as keys and a list of their indexes as values.
 * 2. These lists will be naturally sorted
 * 3. If you are passed the same word twice for distance, return 0 or shortest gap in the list.
 * 4. If you are passed 2 different words, present as keys, then merge the 2 lists and find the shortest gap.
 * 4.1. You could either merge them as a tuple or you could negate the numbers of one list. and find the largest gap
 * between a positive and negative number.	 
 
ARRAY:- 1. Given n arrays of integers find the cartesian product
-- In one output element -first element is always from 1st array, nth element in output is from the nth array

 
ARRAY:- Given an array such that the values are always lesser than size and greater than -1
---- rearrange the array such that a[i] = a[a[i]]
---- Do this such that, no secondary array is used.
---- ANSWER: THINK ABOUT HOW YOU WILL DO IT WITH THE SECONDARY STORAGE, THEN THINK WHY YOU NEED IT, 
		THEN FIND THE ALTERNATIVE.
		
1. Find the majority element in an array i.e. at least n+1/2 times it should appear
https://www.geeksforgeeks.org/majority-element/		
 
 LIST - ARRAY, KTH SMALLEST IN AN UNSORTED ARRAY
 
  * http://www.geeksforgeeks.org/kth-smallestlargest-element-unsorted-array-set-2-expected-linear-time/
 * 
 * Given an array of unsorted numbers,
 * we need to find the k’th smallest element in the given array. 
 *  1. The naive approach would be to search k times - complexity would be k*n
 *  2. The better approach would be to use Quicksort partition - 
 *  it moves a pivot into it's correct position and ensures that all smaller elements are to the left and bigger elements are to the right.
 *  3. So, in a loop, keep running the partition
 *  3.1. if the partition pivots at K then return the pivotted element.
 *  3.2. if the partition pivoted at a place greater than K then set the pivot as the upper bound and repeat
 *  3.3. else, set the partition as the lower bound.
 *  
 *  QUICKSORT PIVOT
 *  
 *  1. Handle the special cases for the list being null, of size 1 and 2
 *  2. set 2 pointers, one after the start position and one at the end
 *  3. while the start pointer has not crossed the end pointer
 *  3.1. scroll to the very last element if possible, otherwise to the first greater-than-START element, i could go past j by 1
 *  3.2. in whatever the first counter hasn't explored go to the first smaller-than-START element
 *  3.3. if pointers haven't crossed yet swap them.
 *  
 *  4. when the loop ends, all lesser elements have been pushed to left of i and vice versa for the greater elements (except element 1)
 *  5. compare element with i-1 (i has stopped upon seeing the greater element, i-1 is smaller than start and should come before start) and swap if necessary.
 *
 
 SINGLY LINKED LIST, DOUBLY LINKED LIST, WITH AND WITHOUT HEADER, - LOOK AT THE CODE.
 
 -- find the middle element.
 -- check for cycles
 -- Switch every 3rd element
 -- Need for header; what if there is an internal pointer; doubly linked?
 -- Sorting and what to watch for?
 
 LIST - ARRAY, BEST DAYS TO BUY AND SELL STOCK
 
 you have to find out the best days to buy and sell in retrospect, but do it linear time
  one n^2 approach is to compare all differences
  
 SOLUTION:- 
 
 1. Keep track of 4 states as you traverse the list - STARTED,MIN_FOUND,MAX_FOUND,CANDIDATE_MIN_FOUND;
 2. create a tuple class to store the index and price
 
 *  1. when you start take the first value as the minimum value.
 *  2. if you are descending a slope that is finding values that are
 *     lower than the minimum, keep resetting the minimum.
 *  3. If a value greater than the minimum is found, then mark it as maximum.
 *  4. For the remainder of the loop if, greater maxima are found, reset the maximum
 *  5. Only other thing which needs to be marked is a lower minimum being found, 
 *     5.1. Mark it as candidate minimum
 *     5.2. Candidate minimum will be reset as a minimum if a maximum with greater difference can be found.
 *     5.3. Candidate minimum will be reset if lower mimima can be found. 

 
 LIST - ARRAY, PUSH ZEROES TO THE END
 
 Given an array of integers, push the zeroes to the end..
 
 SOLUTION 1:-  new and improved
 
 * QUICKSORT PARTITION:- without moving the pivot.
 * 
 *  1. if the input is null or the list size is lesser than 2 return;
 *  2. set up 2 counters, i at the start and j at the end.
 *  3. While i is lesser than j, do
 *  3.1. while i is lesser than the end and while input[i] is not 0, keep incrementing the i
 *  3.2. i will either go out of the loop or stop at a 0
 *  3.3. While j is greater than i and input[j] is zero, keep decrement i.e. no need to swap pre-existing zeroes at the end.
 *  3.4. If you have stopped at a legitimate 0 - non zero combination, swap them and move the counts.
 *  3- Again, if the counts have gone past each other, break out
 * 
 * 
 * 
 * MISTAKES MADE:- When a logic and an index bounds check are together in a check
 * Make sure, you have the bound check in front of logical check, Otherwise the exceptions will be thrown anyway.
 
 SOLUTION 2:-
 
 * Given an array of integers, push the zeroes to the end
 * 
 * 1. if input = null or has nothing in it, return.
 * 2. find the number of zeroes, if the aren't any return.
 * 3. create 2 pointers - 1 at the start of the array and the second where the zeroes are supposed to start.
 * 4. second one should be set at input.length - number of zeroes
 * 5. In a loop
 * 5.a. move the first pointer to the first zero
 * 5.b. if it has crossed into the zero section, return; this can happen when the zeros are already in the end.
 * 5.c. Move the second pointer to the first non zero location, a length check here may not be necessary because 5.b. takes care of it
 * 5.d. Do a swap of the integers at the pointers.
 
 ARRAY - LIST : FIND K CLOSEST NUMBERS TO A GIVEN NUMBER IN A SORTED LIST
 
 * 5. http://www.geeksforgeeks.org/find-k-closest-elements-given-value/
 * 
 * Given a sorted array arr[] and a value X, find the k closest elements to X in arr[]. 
Examples:

Input: K = 4, X = 35
       arr[] = {12, 16, 22, 30, 35, 39, 42, 
               45, 48, 50, 53, 55, 56}
Output: 30 39 42 45
Note that if the element is present in array, then it should not be in output, 
only the other closest elements are required.
 *
 * SOLUTION:-
 * 
 * 1. Do a binary search to find the indexes between which this number falls. 
 * 	2 bounds are required, even if an exact match is found.
 * 2. Set these as starting pointers and copy the numbers, 
 * 	move the pointer depending on which pointer's number is closer to the input number.
 * 3. Break when you hit k, watch out for the array ends.
 
 ARRAY - CIRCULAR QUEUE
 
  * 1. There are two pointers for adding members and removing members to the queue.
 * 1.a. They both move in the same direction.
 * 2. The queue will always have one empty space to distinguish between emptiness and fullness
 * EXIT POINTS - Where to delete
 * ENTER POINTS - where to insert, they will be the same if the entire array is occupied,
 * 
 * 1. Need a string/data array and 2 counters as instance variables.
 * 2. CONSTRUCTOR: if the size of the queue is less than 2 quit
 * 2.a. initialize the array of the given size and initialize the counters to be 0 each.
 * 
 * GET (Retrieve): if enter == exit return, the queue is empty.
 * 1. Else, store the value at exit into out.
 * 2. update the value at exit to be null
 * 3. move exit forward, but with mod function.
 * 
 * ADD: Enter is the place where the next element should be added.
 * 1. Calculate next (add 1 with mod), this is the place where enter will point to after insertion.
 * 2. Now, if next and exit are the same - don't insert, return (Queue is full).
 * 3. else add the new element at enter location; update enter to next.
 
 ARRAY - STACK
 
 *  1. ARRAYS: Stack doesn't need to be circular, only the queue needs to be
 *  2. There is only one counter for the top and it moves in opposite directions for adding and removing.
 *  3. CONSTRUCTOR: initialize the array to the given size and set the pointer to -1 to indicate it is empty.
 *  4. POP: If the counter is lesser than 0, the stack is empty - return
 *  4.1. get the value pointed by the counter, decrement the counter and return the value.
 *  5. PUSH: If the counter is equal or greater than the last index, there is no more space, return
 *  5.1. Increment the counter and add the value at the counter index in the array.
 
 DYNAMIC PROGRAMMING, KNAPSACK OF HIGHEST VALUE
 
 Get the highest valued knap sack for a given weight. Each item has a weight and value.
 
  * PRINCIPLE - Each and every item is either there in the final solution or it is not there
 * 
 * Item absent = Solution for remaining items , same threshold
 * Item present = Solution for (remaining items , (threshold - weight of items )) + value of items
 * 
 * Choose the greater of the two.
 * 
 * 1. if the input sack is null or empty or if the permitted weight is less than or equal to 0
 * 1.2. return null;
 * 2. if the sack size is 1, return an empty sack if the item's weight is greater than the threshold
 * 2.2. else return the input.
 * 3. Else
 * 3.1. Remove the first items from the sack
 * 3.2.  if it's weight is greater than the threshold, return what is best for the rest of the sack
 * 3.3. . Invoke the function recursively for
				//1. This threshold and remaining items
				//2. This threshold - weight of item, and remaining items.
 * 3.3.1 Add the value of the item  to the second result. 
 * 4. return the greater of the two
 * 
 * 
 * MISTAKE MADE:
 * 
 * 1. The knapsack function is not idempotent
 * 2. It changes the state of the input array.
 * 3. So, don't call it multiple times expecting the same result, call it and store the results in a temporary array.
 
 DYNAMIC PROGRAMMING - Longest common sub sequence? Classical Dynamic programming problem.
---- TO BE DONE
---- http://www.geeksforgeeks.org/dynamic-programming-set-4-longest-common-subsequence/ 
-- Youtube videos suck :) above is very easy
-- 1. do the cursory checks for null and size 0  - for the 2 input strings
-- 2. If either one of the string is of size 1, then check if the other string contains this character 
----- return the character as output, if it is present.
----- else return an empty string.
-- 3. Check if the last characters in both strings are the same
----- if yes, then solution = LCS(input1-last char, input2 - last char) + last char
----- if no, then solution = longer(LCS(input1-last char, input2), LCS(input1,input2-last char))
 
 LIST - ARRAY: FIND THE SMALLEST ABSENT NUMBER
 QUESTION - Given an unsorted array of positive non-zero numbers, find the smallest absent number
 
 * Given an array of size N, if the numbers are contiguous 1 to N, 
 * then the solution = N +1;
 * 
 * If any larger number replaces any of the contigous numbers in the list, 
 * then the replaced number (smaller) will become the solution.
  1, 2, 3, 4, 5 - if 300 replaces 3 - then 3 becomes the solution
  3, 2, 1, 5, 4 - if 300 replaces 3 - then 3 becomes the solution
 * 
 * So, regardless of the array's contents, 
 * it is enough to traverse the integers from 1 to Array Length and report the first missing number missing in the array.
 * 
 * So, build a hashtable of all the numbers in the Array and then loop through the integers from 1 to N to check if they are present in the hashtable
 * The first non-present integer is the answer
 * This approach may take O(n) time on average, but it requires O(n) extra space.
 * 
 * An even better approach is described here: 
 * http://www.geeksforgeeks.org/find-the-smallest-positive-number-missing-from-an-unsorted-array/
 * 
 * To mark presence of an element x, we change the value at the index x to negative, 
 * This will be A O(n) time and O(1) extra space solution
 * 
 * Other approaches:-
 * 
 * 1. Sort and check for gap before the smallest, within the list, and then report the greater number. nlogn
 * 2. spatially infinite - array of size largest number initilaized to -1. 
 * Store values in the indexes = values. return the index of the first -1.
 * 3. put values max heap and keep finding the lowest number remaining, compare it with max heap's largest.
 
 LIST - ARRAY: CHECK IF PAIR OF NUMBERS STORED IN AN INTERNAL ARRAY SUM TO GIVEN VALUE
 
  * 1. create an empty array list
 * 2. create an empty set
 * 3. while storing add the number to both the list and the set
 * 4. while testing traverse the list and subtract each number from the supplied value
 * check if the difference is present in the set.
 
 LIST - ARRAY: INTERSECTION of 2 lists
 
 1. Put the first list in a hashset and create a second empty list for the output
 2. Traverse through the second list and add every number that is present in the set into the output.
 
 LIST - Largest Sum Contiguous Subarray
 
 1. Strip out - trailing and leading negative numbers if any
 2. if all are positive, then give out the sum
 3. if all are negative return the smallest abs number
 
 4. transform the list into Zone ojbects (start, end, sum, sign). 
 	The negative zones should sandwich the positive ones. put them in a stack
 5. Set a max zone object = null, mergeable zone objec
 6. while stack is not empty
 6.1. pop the object, {
 
 	if the object is positive 
 	-- if max zone is null or lesser, set this object as max zone
 	
 	if mergeable object is null
 	-- set this object as mergeable
 	
 	else merge into mergeable objet,
 	-- if the new object is bigger than max zone, set it as max zone.
 	
 	Else if the object is negative
 	-- if the mergeable object is not null, merge into it,
 	-- if the sum is negative, set the mergeable object to null.

LIST - Sum of Integers

Given 2 integers represented as 2 arrays of single digit integers, 
add them together and output the result in the form of array of single digit integers. 
For example:
Input: [3, 4, 5] and [9, 4] (represent 345 and 94)
Output: [4, 3, 9] (represents 439)	
 	
 7. Return the max zone object. 
 
 GRAPHS - Toplological sort - very easy
 
 https://www.youtube.com/watch?v=ddTC4Zovtbc 
 
 GRAPHS - Is course structure valid? i.e. given a list of courses, with prerequiste courses
 
  * 1. Create a map of course to down stream courses
 * 2. Create a list of starting courses i.e. have no prerequisites
 * 
 *  iterate until - all course are covered, i.e. the course list becomes empty,
 * 3. If the starting courses are empty, and list has uncovered courses, then return false; 
 * 4. -- Cover, the starting courses i.e. remove them from the list of courses,
 * 5. -- identify their immediate descendants using the map and remove the covered courses from their pre-req
 * 6. -- if the above step creates courses without prereq, they become new starting courses for the next iteration of the loop
 
 GRAPHS - DJIKSTRA'S ALGORITHM
 
 	 https://github.com/gany-c/Algos/blob/master/src/Assign5/NewDjikstra.java
 
 	 * Djikstra: - In a weighted graph, given a source node, find the shortest path to all nodes from the source.
	 * 
	 * Iterative algorithm.
	 * 
	 * 1. Assign the distance value at the source node to be zero, mark it as explored.
	 * 2. Create a priority queue of edges and add all the edges of the source to this priority queue
	 * 3. While the priority queue is not empty
	 * 3.1. get the first edge out
	 * 3.2. if the tail node of the edge is explored continue
	 * 3.3. Else, 
	 * 3.3.1. mark the distance at that node as the edge's head's distance + edge weight
	 * 3.2.2. Add all the edges of the tail node to the Priority queue.
	 * 
	 * NOTICE THAT EVEN THOUGH THERE ARE MULTIPLE PATHS TO A NODE, AND THE EDGES CARRY DIFFERENT WEIGHTS,
	 * THE DISTANCE OF AN EDGE IS NEVER UPDATED.
	 * 
	 *THIS IS BECAUSE A PRIORITY QUEUE IS USED, SHORTER EDGES WILL IMMEDIATELY BUBBLE UP TO THE TOP. 
	 *SO YOU WILL FIRST ARRIVE AT THE NODE THROUGH THE SHORTEST PATH. HENCE NO NEED TO UPDATE
 
 GRAPHS - KRUSKAL'S MININMUM SPANNING TREE
 
  * Given a connected, undirected graph, a spanning tree of that graph is a subgraph that is a tree and connects all the vertices together. 
 * A single graph can have many different spanning trees. 
 * 
 * A minimum spanning tree (MST) or minimum weight spanning tree is then a spanning tree 
 * with weight less than or equal to the weight of every other spanning tree.
 * 
 * Kruskal will most likely start off as a set of disjoint forests, the lowest weight edges can be in all places
 * and then merges together.
 * 
 * ALGO:
 *
 * 1. Take list of nodes as input, if the input list is null or empty return
 * 2. create empty set of edges for the output
 * 3. get a list of the nodes, without the edges
 * 4. get the list of edges sorted by weight
 * 5. For each edge - add edge to both the list of nodes and the output, i.e. set of edges
 * 6. Check if a cycle has been created, if so removed the addition from both places
 * 
 * 1. Checking for a cycle is done in 2 levels here, because we may have a disjoint forest of trees.
 * 1.a. first check starts at a node and traces the traversal path and removes all from the forest.
 * 2.a the second level does a simple BFS on the tree
 * 
 * instead of doing this 2 level general check for cycles, I believe it may be enough to do a one
 * level check at the point addition
 
 PATTERNS - MISC
 
 * Your class should return an iterator that
 * 1. accepts a string as input
 * 2. treat each successive character as an increasing digit (duplicates allowed)
 * 3. return the next number in this number world:- process(“bca”)
 
 HASHING - IMPLEMENT A HASH-TABLE/HASHMAP
 
 * 1. The easiest way is to implement this as an array of linkedlists.
 * 2. Each list is a bucket
 * 3. The number of buckets is a prime number, to lower the number of hash collisions.
 * 4. Assign bucket using hashcode of the object being passed in (divide by number of buckets)
 * 5. Use the equals method to traverse the list of objects/ buckets.
 
what will be the structure of the node in the list? 
Value only? key and value? why do you need the key?

HASHMAP:- Implement an LRU CACHE - TO BE DONE

-- http://www.geeksforgeeks.org/implement-lru-cache/

We use two data structures to implement an LRU Cache.

Queue which is implemented using a doubly linked list. 
The maximum size of the queue will be equal to the total number of frames available (cache size).
The most recently used pages will be near front end and least recently pages will be near rear end.
A Hash with page number as key and address of the corresponding queue node as value.
 
 HEAP 
 
 A MIN HEAP CAN BE CONVERTED TO A MAX HEAP AND VICE VERSA, BY JUST MULTIPLYING THE KEYS BY 1
 
  * Heaps are implemented here
 * https://github.com/gany-c/Algos/blob/master/src/Assign6/MinHeap.java
 * https://github.com/gany-c/Algos/blob/master/src/Assign6/MaxHeap.java
 * 
 * A min-heap is a binary tree where the root always has a lower value than both children.
 * It is implemented using an array where the left and right child are at 2i+1 and 2i+2
 * 
 * EXTRACTION:
 * 
 * 1. return the topmost element
 * 2. decrement the index
 * 3. take bottom-most element and put it in the bottom.
 * 4. correct the heap property downwards. - correctDown()
 * 
 * correctDown()
 * 1. check if the root has children, otherwise return
 * 2. if it has a left child alone, swap with the left child if root is smaller.
 * 3. if it has both children, find the smaller of the two and swap with it. make a recursive call
 * 
 * INSERTION:
 * 
 * 1. insert at the array's end;
 * 2. correct the heap upwards.
 * 3. update the array end pointer. - bubbleUp()
 * 
 *  bubbleUp()
 * 1. if you have reached the top, exit
 * 2. Otherwise get the index of the parent, based on the current index being even or odd
 * 3. Swap the parent and current if parent is larger than the current and continue recursively.
 
 HEAP - MEDIAN MAINTENANCE
 
  *  PROBLEM:-  Create a data structure such that, 
 *  1. elements can be added at random
 *  2. should be be able to identify the median at any time
 *  
 *  
 *  
 *  SOLUTION:-
 *  
 *  1. Create 3 integer instance var for total size, max heap size and min heap size.
 *  2. Create a Max heap to hold the smaller elements,
 *  3. Create a Min heap to hold the larger elements.
 *  
 *  4. CONSTRUCTOR: Given a size, create max heap of half the size and min heap of remaining size
 *  
 *  INSERT METHOD:- 
 *  1. If both heaps are full, then set throw an exception
 *  2. If both heaps are empty then insert into the max heap
 *  
 *  3. If value is lesser than  Max's high
 *  3.1. If max heap is not full just add it there, do a check for size discrepancy of 2 between the 2 heaps,
 *  if yes do the step below
 *  3.1.1  else take the top of max heap and add it to min heap, and then add.
 * 
 * 4. Else if the Min heap is empty 
 * 4.1. do a transfer from min to max
 * 4.2 add to min heap
 * 4.3. again if the min heap is bigger than max by 2, do a min to max transfer
 * 
 * GET MEDIAN FUNCTION:
 * 
 * RETURN THE LARGER HEAP'S TOP OR RETURN ANY TOP.
 
 AMAZON COMPOSITE QUESTION RELATED TO STRINGS:-
 
- You're given a text file of white space delimited words
- Words may be separated by one or more white spaces
- You're asked to compute the following:

- The total number of words in the file
- The frequency of each word
- The top-K most frequently occurring words in the file

- Caveat: You may not use String.split(), Pattern, StringTokenizer, StringBuffer, StringBuilder, etc to split a line of text, i.e., parse the text on your own.

Solution:-

1. Reading from file
--- Can use latest 7 and 8 apis
— Old vs new way 
—— http://howtodoinjava.com/java-8/read-file-line-by-line-in-java-8-streams-of-lines-example/
—— https://gist.github.com/Kevin-Lee/8eb27d4282f19db404bd
--- Use try-with-resources
---Can use lambdas for further processing
2. Tokenizing
-- If String builder and buffer are not acceptabl
-- then 2 counters can be used, for the starting and ending of the token
-- You can check if the word is a separator
-- Make sure you handle the end of the line.
3. Word count
--- Simply add it to a map of word to counts
--- return the size of the map
4. Top K
--- At the end, loop through the contents of the map
--- create tuples for each key value and add it to a priority queue
--- If the priority queue exceeds K in size, remove from the front.
--- at the end you'll have the top K items but in reverse order

STRING - PARENTHESES MATCHING 

-- stack based approach
-- will work even if there are multiple delimiters and interleaving them is equivalent to a bad formation.

STRING - PARENTHESES

	GOAL : GIVEN A STRING CONSISTING OF ( AND ) IN ANY ORDER, 
	DELETE AS LITTLE AS POSSIBLE TO CREATE A BALANCED STRING	
	
	YOUR METHOD: don't know if this will work
	-- CREATE ZONES OR STARTING INDEXES OF VALID AREAS 
	-- STORE THESE IN A STACK 
	-- MERGE THE ZONES AS MUCH AS POSSIBLE
	-- Make the new string with valid zones
	
	SHREYANSH'S METHOD: WORKS
	
	-- RECORD THE UNBALANCED PARENTHESES, AND DELETE THEM
	-- WHEN YOU SEE A LEFT PARENTHESES, RECORD IN THE STACK
	-- WHEN YOU SEE A RIGHT PARENTHESES, POP IT FROM THE STACK
	------IF THERE IS NOTHING TO POP, RECORD IT IN ANOTHER STACK
	--- DELETE WHATEVER REMAINS IN THE STACK
	
STRING - PARENTHESES: BOOLEAN CHECK FOR BEING BALANCED	

https://github.com/gany-c/scala-tutorial/blob/master/Main.scala

-- If the condition is not to use a stack
----- Use recursion
----- 3 parameters are String, index and count of start parentheses
------ increment the count when you see a start, decrement when you see an end parentheses
 
  STRING - CHECK FOR COMPOUND WORDS
 
 	 * PROBLEM: - FIND THE COMPOUND WORDS
	 * i.e. given a set of words - find words that contain other words in the list
	 * BETTER APPROACH - 
	 * 1. if input is null or less than 2 return null
	 * 2. Descending Sort the words by length - Use the Compator (not comparable interface)
	 * Collections.sort(input,new MyComparator());
	 * 3. Create an empty HashSet of words.
	 * 4. Create 2 nested loops
	 * In each inner loop check if the starting word holds any of the subsequent words using indexOf
	 * If yes, add to the hashset
	 * 4.1 move the outer loop.
 
 STRING - CHECK FOR BEING ANAGRAMS
 
 	 * 1. If either string is null return false
	 * 2. if their lengths don't match return false
	 * 
	 * 3. convert both strings to character arrays.
	 * 4. sort both arrays
	 * 5. convert them back to strrings.
	 * 6. Check if they are eaual.
 
 STRING - REVERSE WORDS
 
 * 1. split the words into tokens
 * 2. put the tokens into a stack
 * 3. keep popping the stack and merging the tokens
 * 
 * 1. How to split into tokens?
 * 1.1. Start with an empty string buffer
 * 1.2. traverse the input string
 * 1.3. if you encounter non blank characters append to the buffer.
 * 1.4. else convert the buffer to string and add it to list of tokens
 * 1.4. reinitialize the buffer.
 
 IF A STRING BUFFER IS NOT ALLOWED:-
 
 1. Keep 2 indices - one for word start, one for current
 2. Move both forward if you see whitespaces and you don't have a word starting
 3. move only the current index forward, if you encounter a non whitespace.
 4. if you encounter a whitespace and you have a word start, call substring from start to current
 and reset the indices.
 
 
 STRING - PALINDROME
 
 * MISTAKE DONE HERE:- The apostrophe case was not handled e.g. Mom's 
 * ALWAYS CLARIFY THE PUNCTUATION RULES WHILE SOLVING PALINDROME QUESTIONS
 
 STRING - PALINDROME
 
 	 * 1. if the input string is null, then return false
	 * 2. strip the input of all whitespaces
	 * 3. if what remains is of length 0 or 1, return true
	 * 4. set up two counters, one at the starting and one at the ending.
	 * 5. if what remains is of length 0 or 1, return true
	 * 6. set up two counters, one at the starting and one at the ending.
	 * 7. while they don't cross paths, compare the characters at the counters and move them in opposite directions
	 * 8. return false if the characters don't match.
	 
 STRING - K PALINDROME
 
 	 * EASY :)	
	 * http://www.careercup.com/question?id=6287528252407808
	 *
	 *A k-palindrome is a string which transforms into a palindrome on REMOVING at most k characters. 
	 *
	 * 1. if the input string is null or less than 0 return false
	 * 2. if the input length equals 1, return true
	 * 3. if the input length equals true, then return true if characters are equal or if 
	 * 		k is greater than 0, otherwise return false.
	 * 4. Else, Check recursively
	 * 5. Compare the first and last characters, if they are the same make a recursive call
	 *  with k the same and the start and end lopped off
	 * 5.a.  if they are not the same, make 2 recursive calls, each with one end lopped off and k decremented by 1
	 *  return true if either one of them returns true.
	 
STRING - SEARCH SUB STRING WITH REGULAR EXPRESSION, regexp

 * Check if one string contains another, * the pattern may include * and ?
 * 
 * Solution - code it without any regexp first, add the ? functionality next and the * at the end.
 * 
 * FIND method:
 * 1. slide the pattern string from the postion where the 2 starts overlap to the point where the 2 ends overlap.
 * 2. Invoke the subString function at every point. - Can achieve this through cross recursion, call the original
 * 
 * SUB STRING method:
 * 
 * 1. if the characters of the pattern and the input match or if the pattern has ? 
 * 		invoke the substring function recursively for the next 2 positions.
 * 2. if the current character in the pattern is a *, 
 * 2.1. if it is the last pattern character return true.
 * 2.2. if not, check the remaining pattern recursively at every other point in the index
 * 3. if not, return false.
 
 STRING - ROMAN NUMERAL CONVERTER
 
  * idea is very simple, start at the end and keep adding if you see larger values, else subtract the value from the sum so far
 *
 * 1. Create a static map of characters to integers
 * 2. set a variable for the maximum encountered so far, set a variable for the sum
 * 3. traverse the string in reverse
 * 3.1. get the character and the its value from the map
 * 3.3. if the value is greater than the max value seen, add it to the sume and set it as the new max.
 * 3.4. Else, subtract if from the sum.
 
 STRING - DICTIONARY AND SENTENCE
 
  * PROBLEM: Given a Set of strings as a dictionary and an input String, check if the sentence is composed of words in the string.
 *
 * 1. if the sentence is null or empty or if the dictionary is null return false
 * 2. start from the first character in the input, and keep building larger substrings from the start
 * 2.1. if the dictionary doesn't contain the substring, continue i.e. build a larget prefix
 * 2.2. if there is a match with a dictionary word, 
 * 2.2.1. if you have reached the end of the input, return true
 * 2.2.2. Otherwise make a recursive for the rest of the string and the dictionary.
 
 STRING - STARTS WITH 
 
 Simple character to character comparison starting at the index i in the bigger string.
 
 STRING - INDEX OF
 
 	 * 1. Start with the small string's start overlapping the big one's start
	 * 1.1. slide the small one until the ends overlap.
	 * 2. at each point call startsWith

STRING - TYPE HINT/ SUCCESSOR (Periya Enn Kelvi)

given a list of sentences as input - build a method that recommends the next word..based on the frequency of 1 word succeeding another

basically - it is this:

[
 ["I", "am", "here"],
["I", "like", "Coffee"],
["i", "am", "Hungry"]
]

then predictor("I") -> "am"
Predictor ('am') can be either here or hungry

1. In the constructor, Build Frequency map - this will be a nested map of <String <String, Count>>
2. In the constructor, Collapse the Frequency map to a Successor Map.
3. In the getSuccessor() method - use the Successor Map.

STRING - Given an input string where all spaces have been removed, and an English dictionary, insert spaces back into the string so that it contains all valid words.
Example:
1.Input: s = "cathat", wordDict = ["cat","hat"] Output: "cat hat"
2.Input: s = "applepenapple", wordDict = ["apple","pen"] Output: "apple pen apple"
3.Input: s = "catshat", wordDict = ["cat","hat"] Output: ""
4.Input: s = "catha", wordDict = ["cat","hat"] Output: ""
5.Input: s = "pencathat", wordDict = ["cat","hat"] Output: ""
6.Input: s = "pencathat", wordDict = ["cat","hat", "pen"] Output: "pen cat hat"
This is the key test case, both cat and cater match
7.Input: s = "caterhat", wordDict = ["cat", "cater","hat"] Output: "cater hat"
8.Input: s = "caterhat", wordDict = ["cat", "cater","hat", "er"] Output: ["cater hat"] or ["cat er hat"]

STRING - Given the current directory and a target path i.e. cwd and cd "...", get the full target path. The cd path can start with '/', have mulitiple dirs separated by '/' and . and .. operators

 
 MATHEMATICS - POLYNOMIAL REPRESENTATION
 
 	// A polynomial is represented as a map of 
	// coefficients = keys, exponent powers as values
 
 MATHEMATICS - FIND ALL FACTORS
 
 	 * 1. if input is 0 or lesser return null
	 * 2. if input is 1, return a set containing 1.
	 * 3. i Starting from 1 and until input/2
	 * 3.a. check if input is divisible by i
	 * 3.b. if yes, add divisor and quotient to the set
	 * 4. Use a tree set to print in order
	 
 MATHEMATICS - FIND PRIMARY FACTORS
 
	 * 1. if input equals 0, 1 or 2 return special cases.
	 * 2. create empty output set
	 * 3. for i from 2 to the number
	 * 3.a. if output contains i, skip the loop
	 * 3.b. if i perfectly divides the input
	 * 3.c. add i to the output, recursively invoke it on the quotient
	 
 MATHEMATICS -  A TO POWER OF B
 
 * 1. initialize output to 1
 * 2. if the power param is 0, return 1.
 * 3. initialize term variable to be base
 * 4. if power lesser than 0, set the term to be its own reciprocal
 * 5. get absolute value of the power
 * 6. in a loop from 1 to power variable multiple the output by the base.
 * 7. return output.		 	 
 
 MATHEMATICS -  A TO POWER OF B - FASTER 
  
  	    * 1. initialize output to be 1
	    * 2. if b equals 0, return 1 itself as output
	    * 3. if b equals 1, return the base
	    * 4. if b is less that 0 return the reciprocal of the result of a recursive call with the same base and a negative inversion of the power :)
	    * 5. if the power is even, make a recursive call with power by 2 and return the square of the result.
	    * 6. else do the same with the base multiplying the square.
	    
MATHEMATICS - FIBONACCI

	    * 1. Create a Map for memoization, it need not be refreshed because fibonacci numbers are constants.
	    * 1.1 The iterative approach is even superior to memoization in terms of space complexity
	    * 2. if n is less than 1, return -1
	    * 3. if n equals 1 return 0, if n equals 1
	    * 4. Otherwise, check if the previous 2 fibonacci numbers are available in the map, use them if available otherwise make recursive calls
	    * 5. sum the 2 previous  numbers, add them and add to the map, and return as output.
	    
MATHEMATICS - FIND ALL 6 DIGIT NUMBERS WHICH ARE SQUARES OF THE SUMS OF THEIR 3 DIGIT HALVES
	    * 
	    * Naive approach: call isSquareOfSumOf3digitHalves for all numbers between 100,000
	    * and 1,000,000.
	    * 
	    * Another naive approach would be taking all possible 3 digit pairs - computing their
	    * sums and then their squares. This would again involve 2 nested loops -900 * 1000 times.
	    * 
	    * Better approach: All the sums have to boil down to 100 - 999, if their squares have to
	    * be 6 digit numbers.
	    * 
	    * Check isSquareOfSumOf3digitHalves only on their squares. i.e. on 100 to 999
	    * 
	    * Note: all 3 digit numbers can be candidate sums of the 6 digit pairs. Because the second pair can be 
	    * set to 000. e.g. 123,000 - 100,000 - 999,000	    
	    	    
MATHEMATICS - SQUARE ROOT

	 * Find the square root of a number passed in as a double type, with a second parameter precision.
	 * 
	 * Solution: Do through binary search
	 * 
	 * 1. if the number is less than 0, throw an exception.
	 * 2. if the number is the same as 0 or 1 return the same number.
	  2.5 if the number is between 0 and 1 - return the reciprocal of the result returned
	  with a recursive call on the input's reciprocal :)
	 * 3. else begin a typical binary search, set start =0, end = number
	 * 4. do while end -start is greater than precision.
	 * 4.1. get average.
	 * 4.2. calculate the product of the average.
	 * 4.3. if the product equals the number, return the average.
	 * 4.4. if you fall lesser than the number, set start to mid
	 * 4.5. else set end to mid	 

MATHEMATICS - GIVEN A CERTAIN AMOUNT AND COIN VALUES, FIND ALL COMBINATIONS	 

https://github.com/gany-c/scala-tutorial/blob/master/Main.scala

-- Take the first coin and sum up 3 cases
----- 1. if it is possible to add up to AMOUNT using only the first coin, add 1 to sum
----- 2. if it is possible to add up to AMOUNT without this coin, add the result of recursive invocation without first coin and same sum.
----- 3.in a loop add all the following
-------- decrement AMOUNT by first coin and make a recursive call for the rest of the AMOUNT, with other coins - add this number to sum
--------- keep doing this until AMOUNT becomes lesser than or equal to zero.

Return the sum of 1,2,3

MATHEMATICS - RAMANUJAN'S PARTITIONS :)

 * QUESTION: find all the ways in which a number can be summed, Ramanujan's partitions :)
 * 
 * Find the pairs of numbers which sum up to the input
 * and if any of the pair members is greater than 2, 
 * recursively calculate for that item and combine the other number of the pair with all the sets found
 * 
 * 1. if n is less than 2, return null
 * 2. if n equals 2 return a set containing a single pair of 1 and 1
 * 3. Else, get all the pairs of Sums 
 * 3.1. for each pair
 * 3.1.1 if the first number is greater than 1, recursively call itself for the first number and append the second number to all the generated sets
 * 3.1.2 and vice versa
 * 3.2. Add the 2-sets and the recursively created sets to the output
 * 
 * FINDING 2 Pair sums:
 * 
 * 1. if n is less than 2, retrun 1
 * 2. if n exactly equals 2, return a pair of 1,1
 * 3. for i starting at 1 and up to n/2, create pairs of i and n -i
 
 MATHEMATICS -  find the number of ways in which n elements can be arranged in a BST.
 This is called a Catalan Sequence problem: https://youtu.be/0pTN0qzpt-Y 
 
 If there are n elements, result = sum of (number of topologies with i-th element as root of tree: i = 1 to n)
 STEP 1 - Sort the elements
 STEP 2 - Traverse the list - i as variable:
 number of topologies = number of left topologies * number of right topologies
 Left topology = all nodes smaller than i, or 1 if that number is lesser than 2
 Right topology = all nodes greater than i, or 1 if that number is lesser than 2
 
 MATHEMATICS - Question: Find the next permutation
Given a number, you can rearrange the digits of that number to make a bigger number. Among all such permutations that are greater, one of them is the smallest, find that one.
Examples:
next_permutation(12) = 21
next_permutation(12389) = 12398
next_permutation(34722641) = 34724126

Solution - 

Note - if the digits are in descending order or equal, you cannot create a greater number by swapping.
1. Start from last 2 digits of number check if can create a greater number by swapping
2. Keep moving towards the more significant digits, if you encounter a number smaller than any previously encountered, swap it with the nearest greater digit.
 
 MISC - MERGE OVERLAPPING RANGES
 
  * Given tuples that represent ranges, merge overlapping tuples.
 * [1,5] [2, 7] [8,13]
 * 
 * A variation of this problem is where you are given a set of intervals
 * or processes with start and end times and you have to find when they 
 * overlap i.e. time periods when at least one process was running.
 * 
 * create a static inner class with fields for start, end and a constructor.
 * -- create a method for checking if this tuple is mergeable with another
 * -- create a compare method, which examines start only
 * 
 * 1. if  the input is null or it's size is less than equal to 1 just return the input
 * 2. sort the input by the starting value
 * 3. create a new stack
 * 4. push the first element from the list into the stack
 * 4.1. take the first element from the list
 * 4.2. check if it is mergeable with the top most element in the stack
 * 4.2.1. if yes, pop the element from the stack, merge it with list element 
 * 4.2.2. and push the new element in to the stack.
 * 4.3. else push the list element into the stack.
 * 4.4. return the contents of the stack.	 
	 
MISC - PEEK ITERATOR

 *  How will you create a PeekIterator, which is a wrapper around a regular iterator.
 *  Apart from the hasNext() and next() method you have to implement a peek() method.
 *  
 * create 3 instance variables - 1 for iterator, next value in the list and boolean if the list is empty

 CONSTRUCTOR:
 	 * 1. Store the iterator as instance variable
	 * 2. store the first hasNext boolean return value in the instance variable
	 * 3. if that is true, get the first value from the iterator and store in an instance variable.
	 * 
 HAS-NEXT METHOD:
 	 return the boolean instance variable 
 	 
 PEEK METHOD:
 	 * 1. if the instance boolean variable is true return the stored value.
	 * 2. else throw an exception
 
 GET METHOD: 
 	 * 1. if the instance boolean variable is false throw an exception.
	 * 2. else, store the instance value in a temporary variable
	 * 2.1. update the instance value and variable using the iterator
	 * 2.2. return the temporary variable.

	NOTE: Don't use temp==null as a check in PEEK and GET. 
	That would fail if the iterator itself contains null as one of the values.	 

SORT - BUCKETSORT

When to use it? i.e. Range of values is much smaller than the number of values.
---- Use another smaller array of counts of values, the indexes represent the values.
---- What if there is meta data associated with the values? i.e.  unique records
---- How will you do it without putting a list or stack into each value of the new small count array.

	
SORT - HEAPSORT	

 * very simple :)
 * 
 * HEAPSORT Problem: sorting an array in ascending order
 * 1. Organize the entire as a max heap - using heapify
 * 2. Until the heap boundary is at size 1
 * 2.1. swap the first element and the last element of the heap
 * 2.2. reduce the heap boundary by 1
 * 2.3. correct the heap property
 * 
 * HEAPIFY:
 * 
 * 	 *  1. Traverse the length of the array
	 *  1.1. at every element invoke the recursive bubbleUp method. 
	 *  2. recursive bubbleUp will be required over all nodes, because a single bubbleUp may cover all nodes but will compare immediate neighbors only
	 *  Thus heap property can be violated.
	 *  
	
 * BUBBLEUP:
 * 
 * * 1. Locate the element's parent index
	 * 2. if the parent is lesser that the current element, swap the elements and
	 * 2.1. Call the bubbleUp method recursively at the parent location.
	 * 
	 * 
 *  CORRECTHEAPDOWN: very simple :)
	 * 
	 * 1. Recursive top down method
	 * 2. Start at the index provided, if the children are outside the heap boundary break out
	 * 3. If both children violate the max-heap property, swap the parent with the bigger child and recurse at that index
	 * 4. Else swap the parent with the child that violates the max-heap property, if any and recurse there
	 
SORT - MERGESORT

 * 1. Recursively split the array into 2
 * 2. If array is of size 1 exit
 * 3. Merge the 2 sorted sub-arrays to get a sorted array
 * 
 * Merge:
 * 1. create a temporary array of same size as merged zone.
 * 2. keep 2 pointers and progressively copy the smaller ones from both zones into the new array
 * 3. copy the temporary array into the full zone.
 
 
 SORT - IN PLACE MERGE WITH EXTRA SPACE
 
 	 * PROBLEM:- you are given 2 sorted arrays, the bigger one has empty spaces at the end, 
 	 the same size as the smaller array. 
	 * Merge the 2 arrays in place
	 * 
	 * The only tricky part is the input counter in the larger array =>inPointer2 = outPointer - smallArray.length;
	 * This is best figured out using an example.
	 * 
	 * 
	 * Mistakes were in cut-and-paste, used smallArray instead of bigArray and vice versa	
	 
 SORT -  k way merge of k sorted lists
	 * 
	 * 1. First approach was to maintain K pointers, 1 per sub list and keep incrementing the smallest one you find.
	 * 2. This requires k comparison for each of the k *n items. So the complexity is O(k*k*n)
	 * 3. The way of getting rid of redundant comparisons would using a priority queue of size k
	 * 4. Keep removing from the elements from the priorty-queue=>output and replace it with an element from the sublist to which it belonged
	 * 4.1. :- This is why the Tuple class is needed.
	 * 5. What if you moved one from priority-queue to output and the corresponding list becomes empty? It is OK, doesn't have to be replaced
	 * the priority queue merely reduces in size. 
	 * 
	 * K-WAY MERGE:-
	 * 1. Create a priority queue of Tuples - listIndex and element
	 * 2. initialize the queue with the first number in every list, (and get the total number of elements - not needed)
	 * 3. create an empty output list
	 * 4. while the priority is not empty
	 * 4.1. Get the first tuple from the q
	 * 4.2. Add the value to the output, add get the next element from the sublist based on the index and add it to the Queue
	 * 4.3. If the sublist is empty do nothing.
 	  
SORT - QUICKSORT

	 *  Picturize this list and write
	 *  5, 1, 2, 3, 6, 4, 7, 8, 9, 10
	 *  
	 *  1. Input parameters are the array and the starting and ending indices
	 *  2. if the start and the end indices are the same return
	 *  3. it they are just 2 items apart, do a plain swap.
	 *  4. Take the value at the start index as the pivot,
	 *  5. set one counter at the end and one at the start plus 1 position
	 *  6. while, the counters haven't crossed paths
	 *  6.1. move the first counter forward as long as you see bigger elements
	 *  6.2. move the second counter backward as long as you see smaller elements
	 *  6.3. if the counters still haven't crossed paths swap the 2 elements at the counters, and move them a step
	 *  6.4. continue in loop
	 *  7. After the loop, one final swap of the pivot has to be done; do it if the second counter hasn't reached the pivot position 
	 *  (i.e. entire segment is greater than pivot)
	 *  8. now that the Pivot is placed, make recursive calls - if the right side and left side of the pivot have at least 2 elements.
	 *   	  

BINARY SEARCH TREE

	 * RANK = (Number of elements in the tree which are smaller than the given element) 
	 * 1. Check if the header node or its right child is null,
	 * 1.a. then it is an empty tree, return.
	 * 2. Initialize the values for target, rank and rankCrossed
	 * 3. call the recursive getRank function.
	 * 
	 * 1. This function follows the Inorder paradigm
	 * 2. Make a recursive call to the left child.
	 * 3. Check if rank has been crossed; if yes, then return.
	 * 4. Check if the parameter value is lesser than target value, 
	 * 4.1. if yes increment the rank and make a recursive call to the right child if it is not null
	 * 4.2. if the rank hasn't been crossed and if the current parameter value is greater or equal to target value
	 * 4.2.1. set the rank crossed as true and return.
	 
BINARY SEARCH TREE - FIND THE ITH SMALLEST NUMBER

	 * 1. if the header is null or its right is null return 
	 * 2. initialize the count to 1, the targetCount to the input paramter and result to min value.
	 * 3. Call the recursive overloaded method with the header's right.
	 * 
	 * 1. Follow the inorder paradigm
	 * 2.  if the left is not null, invoke the same method on the left child.
	 * 3. if count so far, is still lesser than target
	 * 3.1. increment the count
	 * 3.2. if the right sub child is not null, recursively invoke it..
	 * 4. if count has arrived at the target, 
	 * 4.1. set the result to be the current node's value.
	 * 4.2. increment the count -- this indicates that the target has been found to the lower nodes.
	 * 5. Else - count has gone past -- target has been found in a lower node -- return without doing anything.
	 
BINARY SEARCH TREE - SEARCH FOR A SPECIFIC VALUE

	 * 1. As usual, check the header and its right node for being null. Else call the recursive search function.
	 * 
	 * 1. if the input node's value and the supplied value are the same, return true.
	 * 2. Else if the input node's value is less than parameter value
	 * 2.1. If the right side is null then return false
	 * 2.2. else recursively invovke the function on the right child.
	 * 3. Else
	 * 3.1. If the left child is null 
	 * 3.2. return false
	 * 3.3. recursively invoke the function on the left side.
	 	 	 
BINARY SEARCH TREE - INSERT

	 * 1. Invoke the recursive insertion function with the header node - same as invoking on its right.
	 * 
	 * 1. if passed in value is lesser than the current node, 
	 * 1.1. Check if the left node is null
	 * 1.2. if yes, then create a node for the value and set left as this node
	 * 1.3. else, make a recursive call to the left child.
	 * 
	 * 2. Else (Departure from not inserting duplicates as shown below)
	 * 2.1. check if the node's right is null
	 * 2.2. if yes, then create a node for the value and set it on the node's right.
	 * 2.3. else make a recursive call for the node's right.
	 
BINARY SEARCH TREE - DELETE

	 * 1. If the tree's header or it's right is null return.
	 * 2. Locate the tree's parent and 
	 * 2.1. create a variable for this node being left or right child
	 * 2.2. create variables for the parent and target nodes.
	 * 3. If the target node is a leaf - then set null as the parent's new descendant 
	 * The side is based on the boolean variable 2.1.
	 * 3.1. If the target node has both branches
	 * 3.2. Find the left most node on the right side. -= LEFT END
	 * 3.3. Make the left child of target, the left child of LEFT END
	 * 3.4. Make the right child of target, the child of parent node based on the variable 2.1.
	 * 4. If the target has just one child, left or right
	 * 4.1. Make the child the descendant of the parent.
	 
BINARY SEARCH TREE - IS IT VALID

	 * 1. Create the inorder traversal and check if order is violated
	 * 2. Don't do the mistake of just checking the immediate children
	 * 
	 * 1. Create instance variables for Inorder ancestor and order being violated.
	 * 2. Check if the header or its right child is null, else invoke the recursive function
	 * 
	 * 1. Invoke the self function on the left child if it is not null.
	 * 2. When it returns check if the global order violation variable is set, if yes return
	 * 2.1. Else, compare the global value with the current node value, if there is a violation return.
	 * 2.2. Else, record the current node value as the global value and invoke on the right child of current node.	 	 

TREE - Reconstruct from Traversal

 * 1. Given the preorder and inorder traversals of a tree, reconstruct it.
 * 
 * 1. Create a map of the preorder elements to their indices
 * 2. Call the recursive  create tree function with
 * 2.1. the newly created map
 * 2.2. the inorder list and 0 and list length as start and end.
 * 
 *  createTree FUNCTION:- 
 * 1. Within the start and end limits supplied, find the element with the lowest preorder position
 * 1.a This is the inorder position of the element with the lowest preorder postion.
 * 2. Create a node with the value at this position.
 * 3. If this  inorder-position is greater than start, recursively invoke this function for the left child node.
 * 4. If the inorder-position is lesser than end, recursively invoke this function for the right child.
 * 
 * FUNCTION lowestPreOrderPos:-
 * 
 * 1. Create 2 variables, one for the inorder index and second for minimum preorder value.
 * 2. Traverse the inorder list from start to end, inclusive.
 * 2.1. Get the element and the index and get's preorder position
 * 2.2. If the preorder index is lesser than stored one, update both the inorder and preorder min indices.
 * 3. return the stored inorder index.
 
 TREE - Reconstrruct from Traversal
 
 	 * THIS METHOD IS ESSENTIALLY SIZE BASED
	 *  -- CALCULATE THE NUMBER OF ELEMENTS IN THE LEFT AND RIGHT SUBTREE USING THE INORDER
	 *  -- SPLIT, THE PREORDER BASED ON THAT.
	 *  
	 *  YOU HAVE TO PASS FOUR INDEXES.
	 * 
	 * 1. if the preorder or inorder list is null or empty or they have a size discrepancy throw an exception.
	 * 2. Get a value to index map of the inorder positions.
	 * 3. Invoke the construct tree function with the preorder list, inorder map, 2 starts and ends for preorder and inorder.
	 * 
	 * FUNCTION - constructTree
	 * 1. create a node with value at preorder start.
	 * 2. if preorder start < end
	 * 2.1. get the inorder position of the preorder start i.e. root.
	 * 2.2. subtract from the inorder start to get size ## Shouldn't you add 1 here? 
	 * 	- No because, you don't want to include the root.
	 * 2.3. If left side size > 0, invoke the function recursively for the left side.
	 * 2.4. --- with preorder start +1, start + left tree size
	 * 2.5. --- and inoder start and inorder pos +1
	 * 3. If there are elements on the right side
	 * invoke the constructTree function recursively.	 
	 
STATIC TREE - 

1. Preorder traversal: print root value, then visit left, then visit right.
2. In order traversal: recursively visit left, print value, recursively visit right.
3. Post order traversal: recursively visit left, recursively visit right, print value.
4.  * Iterative PreOrder: 
 * 1. Create a stack
 * 2. Push the root into the stack
 * 3. While stack is not empty
 * 3.a. pop the element from the stack
 * 3.b. print its value
 * 3.c. if the right is not null, push it into the stack
 * 3.d. if the left is not null, push it on top of the right.
 
 5.  * Iterative In order
 * 1. Create a stack
 * 2. Push left nodes into the stack until you hit the left extreme.
 * 3. While the stack is not empty
 * 3.a. Pop the node and print it.
 * 3.b. if the node has a right child, push all it's left children into the stack.
 
 6.  * Breadth first search
 * 
 * 1. create a Queue
 * 2. add the root into the queue
 * 3. while the queue is not empty
 * 3.a. poll the queue and get the first node out, print the value
 * 3.b. if left is not null, add it to the queue; if the right is not null, add it to the queue.
 * 
 * In general, BFS will finish the nodes of one level and then visit the next level, 
 but cannot tell when it is transiting from a level to another..	
 
 7.  * Printing Levels:
 * 
 * 1. Do breadth first search with 2 queues
 * 2. Initialize 2 queues and add the root to the first queue
 * 3. while the first queue is not empty (actually, when no children have beeen added to the second queue)
 * 3.a. get the element out of the first queue, print its value
 * 3.b. if the left and right are available add them to the next queue
 * 3.c. if you have drained the first queue, add a line break, and set the second queue as the first.
 
 8.  * Depth First Search is identical to preorder
 * Below, you have iterative Preorder.
 
 9.  *  Print all paths to leaves:
 *  1. Start at the root with an empty path
 *  2. At each node, add the current value to the path, with a separator 
 *  3. Recursively, call this method for left child and/or right child 
 *  4. If neither, left or right is present, print the path and exit recursion
 
 10.  * Iterative post order: Excellently done
 * 
 * 1. Create an empty stack of nodes and an empty set of nodes.
 * 2. Push the root into the stack, and navigate to the left most 
 * 3. While stack is not empty
 * 3.a. Pop a node from the stack
 * 3.b. If this node is not contained in right explored and its right node is not null
 * 3.b.a push the node into the stack and push to the left most end of its right sub tree
 * 3.b.b mark the node as right explored.
 * 3.b. - else print the value at the node and continue recursion
 
 11. INORDER SUCCESSOR  
 * 1. set 2 flags targetFound, successor; initialize them to false, null
 * 2. Recursively call the left sub child
 * 3. Next, if successor has been found return;
 * 3.b els if the target has been found mark the current value as successor and return
 * 3.c. if the current value equals the target, mark the target found flag
 * 4. If right is not null, recursively invoke right. 
 
 12. FIND MAXIMUM HEIGHT
 
  * Finding the max height - recursively call left and right height functions and return the max plus 1
 * if both left and right child are missing return 0; if only one is missing invoke on that alone.
 
 13.  * Creating a mirror tree
 * 
 * 1. Clone the root node
 * 2. recursively call the mirror on the right subchild and set it to the left of the output
 * 3. recursively call the mirror on the left subchild and set it to the right of the output
 
 14.  * Zig zag sort is similar to Print levels, 
 * But simply reversing the intermediate queue at every iteration alone won't help
 * Because, the code structure still explores left child and right child. 
 * So another boolean flag is needed to push right child and then left child.
 
  TRY THE 2 STACKS APPROACH - SEEMED GOOD ON PEN AND PAPER
  
  * The 2 stacks approach works perfectly fine.
  * Using a single stack to traverse a tree results in DFS
  * 2 stacks can be used get the zig zag sort going.
  * The nodes of a single level are in one stack, the children go into the next one.
  * The same boolean flag for toggle the left-first vs right-first exploration is used as above.
 
 15. DEEP CLONE  Deep clone is also similar to pre order, 
 clone the current node, 
 call deep clone function on the left and right sub trees.
 
 16. LOWEST COMMON ANCESTOR:-
 
 * -- If one value is the ancestor of another then the former is the Lowest common ancestor.
 * ---- consequently if exactly one value is not present in the tree then the other value will be declare the LCA
 * 
 * --- 1. if current value is equal to either one of the 2 values return it.
 * ----2. if not, recursively invoke on left child and right child
 * ------- if the 2 sides return different non null value, return the current node value.
 * ------- else return the non-value returned from any one side.
 
 
17. A binary tree - can have COMMON-VALUE-SUBTREES or CST, - TO BE DONE
-- Each leaf is a CST
-- 3
  / \
  3  3
  The above is a CST. there are 3 CSTs in that tree
 -- Write a function to count the number of CSTs in a tree. 
 
 18. Print the Top view of a binary tree, i.e. the outer most outline of a tree - TO BE DONE
---- Mistake made: didn't consider the zig zaging of the outer most branch.

19. Question: Get range sum
You are given a binary search tree. Goal is to find sum of all elements in the tree which are in range [low, high].
Input: binary search tree, and range [low, high]
Example: Tree below, range [4, 7]. Output: 22
Explanation: 22 = 4+5+6+7. You can have non-node values as range e.g. 1 and 13.
     6
    /   \
  4     10
 / \     / \
3  5    7  12

Soln - Inorder traversal - don't have to traverse the whole tree. If the curr node is smaller than range, don't have to explore the left node. Similarly if current node is greater than range, don't have to explore the right sub-tree

 
 TRIE:-
 
 Given a list of Strings, find longest commont prefix (not subsequence)
 
 --- Organize the words as a Trie, with a header
 --- The path up to the first point of divergence is the answer.
